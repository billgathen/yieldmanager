{"name":"Yieldmanager","body":"# yieldmanager\r\n\r\nThis gem offers read/write access to [YieldManager's API tools](https://api.yieldmanager.com/doc/) and\r\nad-hoc reporting through the Reportware tool.\r\n\r\nCurrently it generates a fresh wsdl from the api.yieldmanager.com site the\r\nfirst time you use a service (in the future it will use locally-cached\r\ncopies) and re-uses that wsdl for the life of the Yieldmanager::Client object.\r\n\r\nThe current API version is stored in the API_VERSION file.\r\n\r\n### Installation\r\n\r\nYieldmanager is available as a gem for easy installation.\r\n\r\n\tsudo gem install yieldmanager\r\n\r\nor if you're using [RVM](https://rvm.beginrescueend.com/) (and why on earth wouldn't you?)\r\n\r\n\tgem install yieldmanager\r\n  \r\nThe project is available for review/forking on github.com\r\n  \r\n\tgit clone git://github.com/billgathen/yieldmanager.git\r\n\r\nTo use in a Rails project, add this to config/environment.rb:\r\n\r\n\tconfig.gem 'yieldmanager'\r\n\r\n### Creating a Yieldmanager::Client\r\n\r\n\trequire 'yieldmanager'\r\n\t\r\n\t@ym = Yieldmanager::Client.new(\r\n\t\t:user => \"bob\",\r\n\t\t:pass => \"secret\"\r\n\t)\r\n\t\r\nThe default environment is production.\r\nTo access the test environment, use this:\r\n\r\n\t@ym = Yieldmanager::Client.new(\r\n\t\t:user => \"bob\",\r\n\t\t:pass => \"secret\"\r\n\t\t:env => \"test\"\r\n\t)\r\n\r\nThe keys can also be passed as strings: 'user', 'pass' and 'env'.\r\n\r\n**NOTE** Changing the environment after creation has no effect!\r\n\r\n### What API version am I using?\r\n\r\nTo check (or log) the current API version, execute the following:\r\n\r\n\tYieldmanager::Client.api_version\r\n\r\n### Finding available services\r\n\r\n\t@ym.available_services\r\n\r\n### Using a service\r\n\r\n\t@ym.session do |token|\r\n\t\t@currencies = @ym.dictionary.getCurrencies(token)\r\n\tend\r\n\r\n**GOTCHA** In projects with ActiveRecord enabled (i.e., Rails projects)\r\nSOAP will identify returned data as AR objects if there's a\r\nnaming collision. For example, if you're running\r\n\r\n\t@ym.creative.get(token,123)\r\n\r\nand you have an AR objects for a **creatives** table in the db, the\r\nSOAP parser will interpret the returned SOAP object as\r\nan AR Creative object, resulting in bizarre errors. Uniquely\r\nre-name your AR object to eliminate the conflict.\t\r\n\t\r\n### Pagination\r\n\r\nSome calls return datasets too large to retrieve all at once.\r\nPagination allows you to pull them back incrementally, handling\r\nthe partial dataset on-the-fly or accumulating it for later use.\r\n\r\n\tBLOCK_SIZE = 50\r\n\tid = 1\r\n\t@ym.session do |token|\r\n\t\t@ym.paginate(BLOCK_SIZE) do |block|\r\n\t\t\t(lines,tot) = @ym.line_item.getByBuyer(token,id,BLOCK_SIZE,block)\r\n\t\t\t# ...do something with lines...\r\n\t\t\ttot # remember to return total!\r\n\t\tend\r\n\tend\r\n\r\n\r\n### Pulling reports\r\n\r\nAccessing reportware assumes you've used the \"Get request XML\"\r\nfunctionality in the UI to get your request XML, or have\r\ncrafted one from scratch. Assuming it's in a variable called\r\n**request_xml**, you'd access the data this way:\r\n\r\n\t@ym.session do |token|\r\n\t\treport = @ym.pull_report(token, request_xml)\r\n\t\tputs report.headers.join(\"\\t\")\r\n\t\treport.data.each do |row|\r\n\t\t\tputs row.join(\"\\t\")\r\n\t\tend\r\n\tend\r\n\r\nColumn data can be accessed either by index or column name:\r\n\r\n\treport.headers # => ['advertiser_name','seller_imps']\r\n\treport.data[0][0] # => \"Bob's Ads\"\r\n\treport.data[0].by_name('advertiser_name') # => \"Bob's Ads\"\r\n\treport.data[0].by_name(:advertiser_name) # => \"Bob's Ads\"\r\n\r\nIf you call **by_name** with a non-existent column, it will throw an\r\n**ArgumentError** telling you so.\r\n\r\nOr you can extract the report to an array of named hashes, removing\r\ndependencies on the gem for consumers of the data (say, across an API):\r\n\r\n\thashes = report.to_hashes\r\n\thashes[0]['advertiser_name'] # => \"Bob's Ads\"\r\n\r\n**NOTE** Any totals columns your xml requests will be interpreted\r\nas ordinary data.\r\n\r\n### Mocking reports\r\n\r\nWhen simulating report calls without actually hitting Yieldmanager, you can\r\ncreate your own reports.\r\n\r\n\trpt = Yieldmanager::Report.new\r\n\trpt.headers = [\"first\",\"second\"]\r\n\trpt.add_row([1,2])\r\n\trpt.data.first.by_name(\"first\").should == 1\r\n\trpt.data.first.by_name(\"second\").should == 2\r\n\r\n### Wiredumps (SOAP logging)\r\n\r\nTo see the nitty-gritty of what's going over the wire (Yahoo tech support often asks for this),\r\nyou can activate a \"wiredump\" on a per-service basis. Typically you just echo it to standard out.\r\nFor instance:\r\n\r\n\tclient.entity.wiredump_dev = $stdout # on\r\n\tadv = client.entity.get(token,12345)\r\n\tclient.entity.wiredump_dev = nil # off\r\n\r\nFor Rails in a passenger environment, standard out doesn't end up in the logfiles.\r\nInstead, redirect to a file:\r\n\r\n\twiredump = File.new(\"#{Rails.root}/log/wiredump_entity_#{Time.new.strftime('%H%M%S')}.log\",'w')\r\n\tclient.entity.wiredump_dev = wiredump # on\r\n\r\n\tadv = client.entity.get(token,12345)\r\n\r\n\twiredump.flush # make sure everything gets in there before it closes\r\n\tclient.entity.wiredump_dev = nil # off\r\n\r\nThe last 2 lines belong in an ensure block, so the file is created even\r\nwhen there's an error (which is probably why you're doing this).\r\n\r\n### session vs. start_session/end_session\r\n\r\nThe **session** method opens a session, gives you a token to use in your service\r\ncalls, then closes the session when the block ends, even if an exception is\r\nraised during processing. It's the recommended method to ensure you don't\r\nhang connections when things go wrong. If you use start/end, make sure you\r\nwrap your logic in a begin/ensure clause and call end_session from the ensure.\r\n\r\n## RE: Ruby 1.9\r\n\r\nIn an effort to be a good ruby citizen, KarateCode and I have made the gem\r\n1.9 compatible, but it is based on soap4r 1.5.8, which requires a pile of monkey-patches\r\nto get working and not **every** combination of calls and args have been tested\r\nin 1.9. If you're interested in what's been done, check out **lib/soap4r_19_patch**\r\nand [Tomor Doron's blog post](http://tomerdoron.blogspot.com/2009/10/fixing-soap4r-for-ruby-19.html).\r\n\r\n## Note on Patches/Pull Requests\r\n \r\n* Fork the project.\r\n* Make your feature addition or bug fix.\r\n* Add specs for it. This is important so I don't break it in a\r\n  future version unintentionally.\r\n* Commit, do not mess with rakefile, version, or history.\r\n  (if you want to have your own version, that is fine but\r\n  bump version in a commit by itself I can ignore when I pull)\r\n* Send me a pull request. Bonus points for topic branches.\r\n\r\n## Thanks for contributing!\r\n* manlycode[https://github.com/manlycode] (Chris Rittersdorf)\r\n* KarateCode[https://github.com/KarateCode] (Michael Schneider)\r\n\r\n## Copyright\r\n\r\nCopyright (c) 2009-2012 Bill Gathen. See LICENSE for details.","tagline":"Interact with RightMedia's YieldManager API and Reportware products","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}